<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MR Backend</title>
    <link href="{{ url_for('static', path='/css/styles.css') }}" rel="stylesheet">
    <link rel="apple-touch-icon" sizes="180x180" href="{{ url_for('static', path='/favicon/apple-touch-icon.png') }}">
    <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', path='/favicon/favicon-32x32.png') }}">
    <link rel="icon" type="image/png" sizes="16x16" href="{{ url_for('static', path='/favicon/favicon-16x16.png') }}">
    <link rel="manifest" href="{{ url_for('static', path='/favicon/site.webmanifest') }}">
</head>

<body>
    <section id="generate">
        <h2>Generate</h2>
        <form id="generateForm">
            <label for="prompt">Prompt:</label>
            <input type="text" id="prompt" name="prompt">
            <button type="button" id="random-prompt-button">Random Prompt</button>
            <label for="guidance">Guidance Scale: (defaults to 15.0) â€” A higher guidance scale value encourages the model
                to generate images closely linked to the text prompt at the expense of lower image quality. Guidance
                scale is enabled when guidance_scale > 1.</label>
            <input type="number" id="guidance" name="guidance_scale" min="0" max="50" value="15">
            <button type="submit" id="submit-button">Submit</button>
        </form>
        <div id="response"></div>
        <div id="progress-div">
            <progress id="progress-bar" value="0" max="100"></progress>
            <p id="progress-text"></p>
        </div>
    </section>
    <section id="preview">
        <h2>Task Preview</h2>
        <div id="previewResults"></div>
    </section>
    <script>
        function formatDuration(duration) {
            var match = duration.match(/PT(\d+H)?(\d+M)?(\d+(\.\d+)?S)?/);
            var hours = (parseInt(match[1]) || 0);
            var minutes = (parseInt(match[2]) || 0);
            var seconds = (parseFloat(match[3]) || 0);
            return hours * 3600 + minutes * 60 + seconds;
        }
        function getRandomElement(array) {
            let randomIndex = Math.floor(Math.random() * array.length);
            return array[randomIndex];
        }
        let nouns = [
            "an apple", "a backpack", "a car", "a dog", "an elephant", "a fan", "a guitar", "a house",
            "an ice", "a jackal", "a kettle", "a lion", "a mango", "a notebook", "an owl", "a pencil",
            "a quilt", "a rabbit", "a sofa", "a table", "an umbrella", "a vase", "a wallet", "a xylophone",
            "a yak", "a zebra", "an airplane", "a bat", "a camera", "a dolphin", "an egg", "a fork",
            "a goat", "a hat", "an ice cream", "a jellyfish", "a kangaroo", "a lemon", "a mirror",
            "a napkin", "an orange", "a panda", "a quail", "a rose", "a snake", "a tiger", "a unicorn",
            "a violin", "a watch", "an x-ray fish", "a yacht", "a zucchini", "an ant", "a boat", "a candle",
            "a donkey", "an eel", "a flamingo", "some grapes", "a hedgehog", "an ink", "a jaguar", "a kiwi",
            "a lamp", "a monkey", "a nut", "an octopus", "a penguin", "a quokka", "a raccoon", "a spoon",
            "a toaster", "an utensil", "a vulture", "a watermelon", "a xerus", "a yoyo", "a zinnia",
            "an armadillo", "a bell", "a cucumber", "a deer", "an eagle", "a fig", "a giraffe", "a hamster",
            "an iguana", "a jelly", "a koala", "a lizard", "a mushroom", "a nest", "an ostrich", "a peacock",
            "a quince", "a rhinoceros", "a starfish", "a turkey", "a ukelele", "a vacuum"
        ];
        let prompts = [
    "a polar bear",
    "a bonfire",
    "a lion",
    "a donut with blue icing",
    "a voxelized cat",
    "mango sorbet cone",
    "a wedding cake",
    "chicken pot pie",
    "a basket of fruits",
    "a hotdog",
    "a plate of crispy french fries",
    "a traffic light",
    "a bike that looks like a watermelon",
    "a boat that looks like a pineapple",
    "a yield sign",
    "a submarine",
    "a sports car",
    "a ferryboat",
    "an ambulance",
    "a vintage car",
    "a luxury car",
    "a chair that looks like a pineapple",
    "a chair that looks like a vegetable",
    "a chair that looks like a bush",
    "a chair that looks like a tiger",
    "a chair that looks like a hot tub",
    "the person is jumping",
    "the person is standing",
    "the person is bending over",
    "a person that looks like a giraffe",
    "a person that looks like a cheetah",
    "a pair of jeans",
    "a formal suit",
    "apple shoes",
    "a purple boot",
    "a pair of goggles"
];
let furniturePrompts = [
    "a chair made of bamboo",
    "an antique mahogany table",
    "a modern minimalist sofa",
    "a bed with a built-in bookshelf",
    "an office chair with lumbar support",
    "a dresser with a mirror",
    "a wooden rocking chair",
    "a dining table that seats eight",
    "a futon that converts into a bed",
    "a coffee table with storage compartments",
    "a nightstand with a built-in lamp",
    "a bunk bed for kids",
    "an armchair with a footrest",
    "a bookshelf that hangs on the wall",
    "a desk with a hutch",
    "a bar stool with a backrest",
    "a patio table with an umbrella",
    "a vanity with a stool",
    "a sectional sofa for the living room",
    "a loft bed with a desk underneath",
    "a TV stand with shelves",
    "a bedside table with a drawer",
    "a recliner for relaxing",
    "an ottoman with storage inside",
    "a chaise lounge for the bedroom",
    "a wardrobe with sliding doors",
    "a kitchen island with a butcher block top",
    "an adjustable height desk",
    "a console table for the hallway",
    "a shoe rack for the entryway",
    "a cabinet with glass doors",
    "a bench for the end of the bed",
    "a chest of drawers for the bedroom",
    "a coat rack for the foyer",
    "a sideboard for the dining room",
    "a bean bag chair for the game room",
    "a sleigh bed for the master bedroom",
    "a roll-top desk for the office",
    "a daybed for the guest room",
    "a crib for the nursery",
    "a settee for the sitting room",
    "a drafting table for the studio",
    "a Murphy bed for the small apartment",
    "a chifforobe for extra storage",
    "a hope chest for keepsakes",
    "a credenza for the office",
    "a divan for lounging",
    "a chesterfield sofa for the living room",
    "a canopied porch swing",
    "a breakfast nook table",
    "an armoire for the bedroom"
];
        var task_id;
        var randomPromptButton = document.getElementById('random-prompt-button');
        var progressBarDiv = document.getElementById('progress-div');
        var progressBar = document.getElementById('progress-bar');
        var progressText = document.getElementById('progress-text');
        var submitButton = document.getElementById('submit-button');
        var pollingInterval;
        const promptInput = document.getElementById('prompt');
        promptInput.value = getRandomElement(furniturePrompts);

        randomPromptButton.addEventListener('click', function(){
            promptInput.value = getRandomElement(furniturePrompts);
        }); 
        document.getElementById('generateForm').addEventListener('submit', async function (event) {
            event.preventDefault();
            submitButton.disabled = true;
            var prompt = document.getElementById('prompt').value;
            var guidance = document.getElementById('guidance').value;

            try {
                const response = await fetch('/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        guidance_scale: guidance
                    })
                });
                const data = await response.json();
                task_id = data.task_id;
                    progressBar.value = 0
                    progressBarDiv.style.display = "block";
                    var estimatedDurationSecs = formatDuration(data.estimated_duration);
                    progressText.innerText = "Estimated Generation Duration: " + estimatedDurationSecs + " seconds";
                    progressBar.max = Math.ceil(estimatedDurationSecs)
                    var progressValue = 0;
                    pollingInterval = setInterval(function () {
                        if (progressValue < estimatedDurationSecs) {
                            progressValue += 1;
                            progressBar.value = progressValue;

                        }
                        if (progressValue >= estimatedDurationSecs) {
                            checkStatus().then(status => {
                                if (status === "completed") {
                                    // stop polliong.
                                    clearInterval(pollingInterval);
                                    progressBar.value = progressBar.max;
                                    // hide progress bar after a second.
                                    setTimeout(function () {
                                        progressBarDiv.style.display = "none";
                                    }, 1000)
                                    setTimeout(() => fetchPreview(task_id), timeout = 5000);
                                    var previewResultsDiv = document.getElementById('previewResults');
                                    previewResultsDiv.prepend(createDownloadButton(task_id));
                                    previewResultsDiv.prepend(createSpinner());
                                }
                            })

                        }
                    }, 1000);
            } catch (error) {
                console.error('Error:', error);
            }
        });

        async function checkStatus() {
            try {
                const response = await fetch(`/tasks/${task_id}/status`);
                const data = await response.json();
                return data.status;
            } catch (error) {
                console.error('Error:', error);
                return "error";
            }
        };
        async function fetchPreview(task_id, retries = 10, retryInterval = 1000) {
            const previewResultsDiv = document.getElementById('previewResults');

            try {
                const response = await fetch(`/tasks/${task_id}/preview`);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const blob = await response.blob();
                var url = URL.createObjectURL(blob);
                var img = document.createElement('img');
                img.src = url;
                img.style.maxWidth = '100%'; // To ensure the image fits in the container
                previewResultsDiv.prepend(img);
                removeSpinners();
                submitButton.disabled = false;
            } catch (error) {
                if (retries > 0) {
                    console.log(`Fetch failed, retrying in ${retryInterval}ms...`);
                    setTimeout(() => fetchPreview(task_id, retries - 1, retryInterval), retryInterval);
                } else {
                    console.error('Error:', error);
                }
            }
        }
        function createDownloadButton(task_id) {
            const downloadButton = document.createElement("button");
            downloadButton.textContent = `Download task ${task_id}`;
            downloadButton.onclick = function () {
                fetch(`/tasks/${task_id}/results`)
                    .then(response => response.blob())
                    .then(blob => {
                        var url = URL.createObjectURL(blob);
                        var a = document.createElement('a');
                        a.href = url;
                        a.download = `${task_id}_results.obj`;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                    })
                    .catch((error) => {
                        console.error('Error:', error);
                    });
            };
            return downloadButton;
        }
        function createSpinner() {
            const spinner = document.createElement('div');
            spinner.className = 'spinner';
            return spinner;
        }
        function removeSpinners() {
            // Get all elements with class "spinner"
            let spinners = document.querySelectorAll('div.spinner');

            // Loop through all found elements and remove them
            spinners.forEach(function (spinner) {
                spinner.parentNode.removeChild(spinner);
            });
        }
    </script>
</body>

</html>