<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MR Backend</title>
    <link href="{{ url_for('static', path='/css/styles.css') }}" rel="stylesheet">
</head>

<body>
    <section id="generate">
        <h2>Generate</h2>
        <form id="generateForm">
            <label for="prompt">Prompt:</label>
            <input type="text" id="prompt" name="prompt">
            <label for="guidance">Guidance Scale:</label>
            <input type="number" id="guidance" name="guidance_scale">
            <button type="submit">Submit</button>
        </form>
        <div id="response"></div>
        <div id="progress-div">
            <progress id="progress-bar" value="0" max="100"></progress>
            <p id="progress-text"></p>
        </div>
    </section>
    <section id="preview">
        <h2>Task Preview</h2>
        <div id="previewResults"></div>
    </section>
    <script>
        function formatDuration(duration) {
            var match = duration.match(/PT(\d+H)?(\d+M)?(\d+(\.\d+)?S)?/);
            var hours = (parseInt(match[1]) || 0);
            var minutes = (parseInt(match[2]) || 0);
            var seconds = (parseFloat(match[3]) || 0);
            return hours * 3600 + minutes * 60 + seconds;
        }

        var task_id;
        var progressBarDiv = document.getElementById('progress-div');
        var progressBar = document.getElementById('progress-bar');
        var progressText = document.getElementById('progress-text');
        var pollingInterval;

        document.getElementById('generateForm').addEventListener('submit', function (event) {
            event.preventDefault();

            var prompt = document.getElementById('prompt').value;
            var guidance = document.getElementById('guidance').value;

            fetch('/generate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    prompt: prompt,
                    guidance_scale: guidance
                })
            }

            )
                .then(response => response.json())
                .then(data => {
                    task_id = data.task_id;
                    progressBar.value = 0
                    progressBarDiv.style.display = "block";
                    var estimatedDurationSecs = formatDuration(data.estimated_duration);
                    progressText.innerText = "Estimated Generation Duration: " + estimatedDurationSecs + " seconds";
                    progressBar.max = Math.ceil(estimatedDurationSecs)
                    var progressValue = 0;
                    pollingInterval = setInterval(function () {
                        if (progressValue < estimatedDurationSecs) {
                            progressValue += 1;
                            progressBar.value = progressValue;

                        }
                        if (progressValue >= estimatedDurationSecs) {
                            checkStatus().then(status => {
                                if (status === "completed") {
                                    // stop polliong.
                                    clearInterval(pollingInterval);
                                    progressBar.value = progressBar.max;
                                    // hide progress bar after a second.
                                    setTimeout(function () {
                                        progressBarDiv.style.display = "none";
                                    }, 1000)
                                    setTimeout(() => fetchPreview(task_id), timeout = 5000);
                                    var previewResultsDiv = document.getElementById('previewResults');
                                    previewResultsDiv.prepend(createDownloadButton(task_id));
                                }
                            })

                        }
                    }, 1000);
                })
                .catch((error) => {
                    console.error('Error:', error);
                });
        });

        function checkStatus() {
            return fetch(`/tasks/${task_id}/status`)
                .then(response => response.json())
                .then(data => {
                    return data.status;
                })
                .catch((error) => {
                    console.error('Error:', error);
                    return "error";
                });
        };


        // function fetchPreview() {
        //     fetch(`/tasks/${task_id}/preview`)
        //         .then(response => response.blob())
        //         .then(blob => {
        //             var url = URL.createObjectURL(blob);
        //             // Create an image element and set its src to the Blob URL
        //             var img = document.createElement('img');
        //             img.src = url;
        //             img.style.maxWidth = '100%'; // To ensure the image fits in the container
        //             var previewResultsDiv = document.getElementById('previewResults');
        //             previewResultsDiv.prepend(img);
        //         })
        //         .catch((error) => {
        //             console.error('Error:', error);
        //         });
        // }
        function fetchPreview(task_id, retries = 10, retryInterval = 1000) {
            fetch(`/tasks/${task_id}/preview`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.blob();
                })
                .then(blob => {
                    var url = URL.createObjectURL(blob);
                    var img = document.createElement('img');
                    img.src = url;
                    img.style.maxWidth = '100%'; // To ensure the image fits in the container
                    var previewResultsDiv = document.getElementById('previewResults');
                    previewResultsDiv.prepend(img);
                })
                .catch((error) => {
                    if (retries > 0) {
                        console.log(`Fetch failed, retrying in ${retryInterval}ms...`);
                        setTimeout(() => fetchPreview(task_id, retries - 1, retryInterval), retryInterval);
                    } else {
                        console.error('Error:', error);
                    }
                });
        }

        function createDownloadButton(task_id) {
            const downloadButton = document.createElement("button");
            downloadButton.textContent = `Download task ${task_id}`;
            downloadButton.onclick = function () {
                fetch(`/tasks/${task_id}/results`)
                    .then(response => response.blob())
                    .then(blob => {
                        var url = URL.createObjectURL(blob);
                        var a = document.createElement('a');
                        a.href = url;
                        a.download = `${task_id}_results.obj`;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                    })
                    .catch((error) => {
                        console.error('Error:', error);
                    });
            };
            return downloadButton;
        }
    </script>
</body>

</html>